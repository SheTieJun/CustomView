<resources>
    <string name="app_name">CustomView</string>
    <string name="level_des_img">学习等级由连续学习天数决定，目前共有8个等级，它们对应的连续学习天数为：</string>
    <string name="medal_string">获得了专属勋章<font color="#FF4812">XXXX</font></string>
    <string name="medal_string_3">1.专属赠品课程已完成解锁XXXXX \n2.完成学习任务可以<font color="#FF4812">XXXXXX</font></string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">Hello blank fragment</string>
    <string name="test_string">Android 8.0 (API level 26) and Android Support Library 26 introduce support for APIs to request fonts from a provider application instead of bundling files into the APK or letting the APK download fonts. The feature is available on devices running Android API versions 14 and higher through the Support Library 26.</string>
    <string name="info"><![CDATA[public static abstract class Behavior<V extends View>{ public Behavior() { } public Behavior(Context context, AttributeSet attrs) {} // 给 Behavior 设置 LayoutParams 时会调用 public void onAttachedToLayoutParams(@NonNull CoordinatorLayout.LayoutParams params) {} // LayoutParams 移除时会调用 public void onDetachedFromLayoutParams() {} // 是否拦截 CoordinatorLayout 发过了的点击事件 public boolean onInterceptTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev) { return false; } // 接收 CoordinatorLayout 发过了的点击事件 public boolean onTouchEvent(CoordinatorLayout parent, V child, MotionEvent ev) { return false; } // 设置 Behavior 所在 View 之外的 View 的蒙层颜色 @ColorInt public int getScrimColor(CoordinatorLayout parent, V child) { return Color.BLACK; } // 设置蒙层的透明度 @FloatRange(from = 0, to = 1) public float getScrimOpacity(CoordinatorLayout parent, V child) { return 0.f; } // 是否对 Behavior 绑定 View 下面的 View 的进行交互， // 默认是是根据 getScrimOpacity 的透明度决定的 public boolean blocksInteractionBelow(CoordinatorLayout parent, V child) { return getScrimOpacity(parent, child) > 0.f; } // 当前 View 是否依赖指定 View 进行变化 public boolean layoutDependsOn(CoordinatorLayout parent, V child, View dependency) { return false; } // 依赖的 View(dependency)变化时的回调 public boolean onDependentViewChanged(CoordinatorLayout parent, V child, View dependency) { return false; } // 依赖的 View 被移除时的回调 public void onDependentViewRemoved(CoordinatorLayout parent, V child, View dependency) { } // CoordinatorLayout 在测量时会回调这个方法 public boolean onMeasureChild(CoordinatorLayout parent, V child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { return false; } // CoordinatorLayout 在布局时会回调这个方法 public boolean onLayoutChild(CoordinatorLayout parent, V child, int layoutDirection) { return false; } // 设置 tag public static void setTag(View child, Object tag) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); lp.mBehaviorTag = tag; } // 获取 tag public static Object getTag(View child) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); return lp.mBehaviorTag; } // 当 CoordinatorLayout 内有 NestedScrollView 开始滑动的时候回调 public boolean onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type) { if (type == ViewCompat.TYPE_TOUCH) { return onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, axes); } return false; } // 当上面的 onStartNestedScroll 返回 true,会回到改方法 public void onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type) { if (type == ViewCompat.TYPE_TOUCH) { onNestedScrollAccepted(coordinatorLayout, child, directTargetChild, target, axes); } } // 当 CoordinatorLayout 内有 NestedScrollView 停止滑动的时候回调 public void onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, @NestedScrollType int type) { if (type == ViewCompat.TYPE_TOUCH) { onStopNestedScroll(coordinatorLayout, child, target); } } // 当 CoordinatorLayout 内有 NestedScrollView 滑动过程中的回调 public void onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type) { if (type == ViewCompat.TYPE_TOUCH) { onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); } } // 在 onNestedScroll 之前回调该方法 public void onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type) { if (type == ViewCompat.TYPE_TOUCH) { onNestedPreScroll(coordinatorLayout, child, target, dx, dy, consumed); } } // 是否滑动的惯性事件处理 public boolean onNestedFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, float velocityX, float velocityY, boolean consumed) { return false; } // 滑动的惯性事件开始的回调 public boolean onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View target, float velocityX, float velocityY) { return false; } // 如果给CoordinatorLayout设置了fitSystemWindow=true,可以在这里自己处理WindowInsetsCompat @NonNull public WindowInsetsCompat onApplyWindowInsets(CoordinatorLayout coordinatorLayout, V child, WindowInsetsCompat insets) { return insets; } // 在CoordinatorLayout的requestChildRectangleOnScreen()中被调用 public boolean onRequestChildRectangleOnScreen(CoordinatorLayout coordinatorLayout, V child, Rect rectangle, boolean immediate) { return false; } }]]></string>
</resources>
